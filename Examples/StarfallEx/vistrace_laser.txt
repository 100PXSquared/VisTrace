--@name VisTrace Laser
--@author Derpius
--@model models/maxofs2d/cube_tool.mdl
--@shared

if CLIENT then
    -- PARAMETERS
    local laserModel    = "models/maxofs2d/cube_tool.mdl"
    local laserMat      = "models/props_combine/tprings_globe"
    local laserColour   = Color(255, 0, 0, 100)
    local bias          = 0.01
    local maxLength     = 64
    local shouldNetwork = false
    
    -- Init path segments
    local path = {}
    for i = 1, maxLength do
        path[i] = holograms.create(Vector(), Angle(), laserModel, scale)
        path[i]:setMaterial(laserMat)
        path[i]:setColor(laserColour)
    end
    
    if player() ~= owner() then
        net.receive("update_laser", function()
            for i = 1, maxLength do
                path[i]:setPos(net.readVector())
                path[i]:setAngles(net.readAngle())
                path[i]:setScale(net.readVector())
            end
        end)
        return
    end
    
    local function reflect(I, N) -- Reflects an incidence vector I about the normal N
        return I - 2 * N:dot(I) * N
    end
    
    local function refract(I, N, ior) -- Refracts an incidence vector I about the normal N through a medium with an index of refraction ior
        local cosI = I:dot(N)
        local etaI, etaT = 1, ior
        
        if cosI < 0 then
            cosI = -cosI
        else
            etaT, etaI = etaI, ior
            N = -N
        end
        
        local eta = etaI / etaT
        local k = 1 - eta^2 * (1 - cosI^2)
        return k >= 0 and eta * I + (eta * cosI - math.sqrt(k)) * N
    end
    
    -- Initialisation
    local chip = chip()
    
    -- Bake vismesh scale
    local verts = mesh.getModelMeshes(laserModel)[1].verticies
    local min, max = Vector(math.huge), Vector(-math.huge)
    for _, v in pairs(verts) do
        for i = 1, 3 do
            if v.pos[i] < min[i] then min[i] = v.pos[i] end
            if v.pos[i] > max[i] then max[i] = v.pos[i] end
        end
    end
    local scale = 1 / (max - min)
    
    local ents = find.all(function(ent)
        local cls = ent:getClass()
        return (cls == "prop_physics" or cls == "prop_ragdoll") and isValid(ent:getOwner())
    end)
    vistrace.rebuildAccel(ents)
    
    local lastChipPos = chip:getPos()
    local networking = false
    hook.add("think", "trace", function()
        local origin = chip:getPos()
        local direction = chip:getForward()
        
        if origin ~= lastChipPos and not networking then
            lastChipPos, networking = origin, shouldNetwork
            
            -- Hide last frame's segments
            for i = 1, maxLength do path[i]:setScale(Vector()) end
            
            if shouldNetwork then
                net.start("update_laser")
                net.writeUInt(maxLength, 8)
            end
            for length = 1, maxLength do
                local function buildSegment()
                    local hit = vistrace.traverseScene(origin, direction)
                    if not hit.Hit then return end
                    
                    local holoPos, holoAng, holoScale = (origin + hit.HitPos) / 2, direction:getAngle(), Vector(scale[1] * origin:getDistance(hit.HitPos), scale[2], scale[3])
                    
                    path[length]:setPos(holoPos)
                    path[length]:setAngles(holoAng)
                    path[length]:setScale(holoScale)
                    
                    if shouldNetwork then
                        net.writeVector(holoPos)
                        net.writeAngle(holoAng)
                        net.writeVector(holoScale)
                    end
                    
                    if not isValid(hit.Entity) then return end
                    
                    local normal = hit.HitNormal--Geometric
                    local inside = direction:dot(normal) > 0
                    
                    local mat = hit.Entity:getMaterial()
                    if mat == "debug/env_cubemap_model" then
                        if inside then normal = -normal end
                        origin = hit.HitPos + normal * bias
                        direction = reflect(direction, normal)
                    elseif mat == "phoenix_storms/glass" then
                        local refractVec = refract(direction, normal, 1.52)
                        if inside then normal = -normal end
                        if refractVec then
                            origin = hit.HitPos - normal * bias
                            direction = refractVec
                        else
                            origin = hit.HitPos + normal * bias
                            direction = reflect(direction, normal)
                        end
                    else return end
                end
                buildSegment()
            end
            if shouldNetwork then
                net.send()
            end
        end
    end)
    net.receive("net_finished", function() networking = false end)
else -- Serverside
    net.receive("update_laser", function()
        net.start("update_laser")
        local length = net.readUInt(8)
        for i = 1, length do
            net.writeVector(net.readVector())
            net.writeAngle(net.readAngle())
            net.writeVector(net.readVector())
        end
        net.send()
        net.start("net_finished")
        net.send()
    end)
end