                                   **VisTracing in One Weekend**
                      Inspired by [Ray Tracing in One Weekend](https://raytracing.github.io/books/RayTracingInOneWeekend.html) by [Peter Shirley](https://github.com/petershirley)

Introduction
============
Many people have written ray tracers in Garry's Mod, but few have explored the more serious side of light transport, reserving themselves to basic lighting models and guesswork. With VisTracing in One Weekend I hope to provide a gateway into the wider field of light transport, while remaining in GMod and assuming only a minimal understanding of ray tracing.  

If you're entirely unfamiliar with ray tracing, specifically ray tracing in GMod, I would recommend you read Peter Shirley's Ray Tracing in One Weekend which is linked above, and is the inspiration for this book.  

By the end of each section you should have a solid groundwork to either move into the next section with, or to develop onto yourself. And by the end of the book you'll have a pretty decent tracer.

While you could technically follow along without these, the book assumes you'll be using them:
* Garry's Mod
* VisTrace (subscribe to the Workshop addon and download the latest release binary from the GitHub)

You should also already be familiar with Lua (specifically GLua) and basic rendering terminology like shading.  

You'll be implementing the tracer as a simple GLua script run with `lua_openscript_cl` from the console, however you could follow along from Starfall or even write a fully fledged addon around the renderer.  

Drawing an Image
----------------

Before we get into the nitty gritty of light transport, we need to actually be able to draw pixels to our screen. While there are *many* ways to do this ranging from drawing to a physical screen in the world, to a VGUI frame you can use like a mini application, I've opted for the simplest and most efficient for this step (however you can ignore this and use whatever method you prefer if you're already familiar with rendering in GMod).  

To start with we need a script to work in, and an addon to place that script in. Create a new folder in your `garrysmod/addons` folder with any name you like, then create a subfolder called `lua` and a file in that folder called `vistracer.lua` (you can of course use whatever name you want, however the book assumes this is what you called it). You should now have the file `garrysmod/addons/youraddonname/lua/vistracer.lua`.  

Open the file in your text editor of choice (I recommend vscode with sumneko's Lua extension and the GLua annotations) and add the following
~~~ lua
print("VisTracing in One Weekend!")
~~~

![Console Output](./images/vistracing-in-one-weekend/console-print.png)

Launch GMod and start singleplayer (or join a multiplayer server with clientside Lua enabled), open console with the grave/backtick key, and enter `lua_openscript_cl vistracer.lua`. You should see `VisTracing in One Weekend!` appear in your console! If not then check that `sv_allowcslua` is set to `1`, and that GMod has been restarted since you created `vistracer.lua` (it only hotloads existing files).  

Now to draw something to the screen we need a render context, and in this case I've chosen the `PostDrawHUD` hook as a simple way to get pixels above everything except the menu. Remove the print we added and replace it with the hook
~~~ lua
hook.Add("PostDrawHUD", "VisTracer", function()

end)
~~~  

This wont do anything yet, but go ahead and run it just to check everything's working. We have a render context, but we need to actually draw something. For now lets just use a red rectangle
~~~ lua
hook.Add("PostDrawHUD", "VisTracer", function()
	~~~ lua highlight
	surface.SetDrawColor(255, 0, 0)
	surface.DrawRect(0, 0, 256, 256)
	~~~ lua
end)
~~~

![`surface.DrawRect`](./images/vistracing-in-one-weekend/surface-draw.png)

You may be thinking that this is how we'll render an entire image, however if you were to add a print to this hook you'd see that it's called every frame. You can imagine how laggy our game would get if we were ray tracing a scene every frame in Lua.

Instead we need a way to render a set of pixels only once, and save them for future frames. To do this we're going to use *render targets*, which are a special kind of texture we're able to draw to, and the pixels we draw will be saved indefinitely (quite literally in fact, GMod doesn't destroy render targets until the game closes).  

First of all we need to create a render target to use, in addition to a material to assign the render target to as a base texture in order to draw it to the screen later
~~~ lua
local rt = GetRenderTargetEx(
	"VisTracer",                     -- Name of the render target
	1, 1, RT_SIZE_FULL_FRAME_BUFFER, -- Resize to screen res automatically
	MATERIAL_RT_DEPTH_SEPARATE,      -- Create a dedicated depth/stencil buffer
	bit.bor(1, 256),                 -- Texture flags for point sampling and no mips
	0,                               -- No RT flags
	IMAGE_FORMAT_RGBA8888            -- RGB image format with 8 bits per channel
)

local rtMat = CreateMaterial("VisTracer", "UnlitGeneric", {
	["$basetexture"] = rt:GetName(),
	["$translucent"] = "1" -- Enables transparency on the material
})

...
~~~

Next we draw the render target to the screen
~~~ lua
...

hook.Add("PostDrawHUD", "VisTracer", function()
	~~~ lua delete
	surface.SetDrawColor(255, 0, 0)
	surface.DrawRect(0, 0, 256, 256)
	~~~ lua highlight
	render.SetMaterial(rtMat)
	render.DrawScreenQuad() -- Draws a quad to the entire screen
	~~~ lua
end)
~~~

If you run this with `lua_openscript_cl vistracer.lua` you should get a black screen (don't worry, use `lua_run_cl hook.Remove("PostDrawHUD", "VisTracer")` to get rid of the hook). This isn't exactly what we want, so lets try drawing some pixels.  

While we could draw to the render target immediately when we run our script, we're going to want to split the drawing over multiple frames for later (ray tracing single threaded in Lua is not fast). To do this we can ignore more complicated (and slower) methods of spreading our code over multiple frames, and just render one row per frame. We also need to define an x and y resolution to draw, which we'll place at the top of the file (this is where all of our parameters will go)
~~~ lua highlight
local RESX, RESY = 256, 256
~~~ lua

...


~~~ lua highlight
local y = 0
~~~ lua
hook.Add("PostDrawHUD", "VisTracer", function()
	~~~ lua highlight
	if y < RESY then
		render.PushRenderTarget(rt)

		for x = 0, RESX - 1 do
			render.SetViewPort(x, y, 1, 1)
			render.Clear(255, 0, 0, 255, true, true)
		end

		render.PopRenderTarget()
		y = y + 1
	end
	~~~ lua

	render.SetMaterial(rtMat)
	render.DrawScreenQuad()
end)
~~~

Running this should produce a 256x256 red rectangle just like the original `surface.DrawRect` method, except we now have control over the colour of individual pixels and we're only drawing each pixel once. You may also notice that we still have the same problem as before where the entire screen is black except for where we drew our rectangle.

To fix that we'll add a `setup` flag and clear the render target with 0 alpha before we start writing.
~~~ lua
...

local y = 0

	~~~ lua highlight
local setup = true
	~~~ lua
hook.Add("PostDrawHUD", "VisTracer", function()
	if y < RESY then
		render.PushRenderTarget(rt)

		~~~ lua highlight
		if setup then
			render.Clear(0, 0, 0, 0, true, true)
			setup = false
		end
		~~~ lua

		for x = 0, RESX - 1 do
			render.SetViewPort(x, y, 1, 1)
			render.Clear(255, 0, 0, 255, true, true)
		end

		render.PopRenderTarget()
		y = y + 1
	end

	render.SetMaterial(rtMat)
	render.DrawScreenQuad()
end)
~~~

Et voila! You should now have a significantly slower to draw red rectangle! Not impressed? Well lets draw something slightly more interesting that we couldn't do with a simple `surface.DrawRect` call...
~~~ lua
		...

		for x = 0, RESX - 1
			render.SetViewPort(x, y, 1, 1)

			~~~ lua delete
			render.Clear(255, 0, 0, 255, true, true)
			~~~ lua

			~~~ lua highlight
			render.Clear(x / (RESX - 1) * 255, y / (RESY - 1) * 255, 0, 255, true, true)
			~~~ lua
		end

		...
~~~

Running our script now should produce a nice gradient from black to red on the x axis, and black to green on the y axis. You may also notice that the pixels are black in the *top left* of the rectangle, and not the bottom left as you might expect.

![Red on the X axis and green on the Y axis](./images/vistracing-in-one-weekend/xy-square.png)

Tracing a Ray
-------------

Before we dig into the meat of ray tracing, we need to know how to trace a ray, and to know that we need to know what a "ray" even is.

While it makes sense to think of a ray as a single "ray" of light (light is far more complicated than that in reality), it's actually the total of *all* light that follows a specific line defined by our ray.

Additionally we can define a ray as $\mathbf{x} = \mathbf{o} + t\mathbf{d}$, where $\mathbf{x}$ is the hit point of the ray, $\mathbf{o}$ is the origin, $\mathbf{d}$ is the direction, and $t$ is the *time* or distance along the ray.

Tracing a ray in this context is solving the above equation for the lowest positive value of $t$, which we do by testing every part of the scene geometry for intersections with the ray. We wont have to worry about tracing the ray ourselves, as VisTrace handles this for us, but it's good to know roughly what's going on under the hood.

To trace a ray with VisTrace, it needs to know the scene geometry we want to trace before we can actually trace with it, which we can do by building an *acceleration structure*. The specifics of ray tracing acceleration structures are well outside the scope of this book, but if you want to look into them then VisTrace uses a [bounding volume hierarchy](https://en.wikipedia.org/wiki/Bounding_volume_hierarchy).

Thankfully building an acceleration structure with modern versions of VisTrace is easy, we simply call a function passing in an array of entities we want to intersect with, along with a boolean to toggle intersections with the world (by default it's true). For now we'll just trace any entities whose class starts with `prop_` and disable world tracing. I've also added some comments to help keep our code clean

~~~ lua highlight
----------------
-- Parameters --
----------------
~~~ lua
local RESX, RESY = 256, 256


~~~ lua highlight
----------------
--    Init    --
----------------
local accel = vistrace.CreateAccel(ents.FindByClass("prop_*"), false)
~~~ lua

local rt = GetRenderTargetEx(
	"VisTracer",                     -- Name of the render target
	1, 1, RT_SIZE_FULL_FRAME_BUFFER, -- Resize to screen res automatically
	MATERIAL_RT_DEPTH_SEPARATE,      -- Create a dedicated depth/stencil buffer
	bit.bor(1, 256),                 -- Texture flags for point sampling and no mips
	0,                               -- No RT flags
	IMAGE_FORMAT_RGBA8888            -- RGB image format with 8 bits per channel
)

...
~~~

Now we have our scene geometry in an acceleration structure we can start tracing some rays. While we could put all of this in the render hook from the previous section, to help with readability we're going to create a new function above our hook called `TracePixel`, which will be called from the hook with the x and y coordinates of the current pixel and will return an RGB vector
~~~ lua
...


~~~ lua highlight
local function TracePixel(x, y)
	return Vector(x / (RESX - 1), y / (RESY - 1), 0)
end
~~~ lua

local y = 0
local setup = true
hook.Add("PostDrawHUD", "VisTracer", function()
	if y < RESY then
		render.PushRenderTarget(rt)
		if setup then
			render.Clear(0, 0, 0, 0, true, true)
			setup = false
		end

		for x = 0, RESX - 1 do
			~~~ lua highlight
			local rgb = TracePixel(x, y)
			~~~ lua

			render.SetViewPort(x, y, 1, 1)
			~~~ lua delete
			render.Clear(x / (RESX - 1) * 255, y / (RESY - 1) * 255, 0, 255, true, true)
			~~~ lua highlight
			render.Clear(rgb[1] * 255, rgb[2] * 255, rgb[3] * 255, 255, true, true)
			~~~ lua
		end

		render.PopRenderTarget()
		y = y + 1
	end

	render.SetMaterial(rtMat)
	render.DrawScreenQuad() -- Draws a quad to the entire screen
end)
~~~

This should produce the exact same image as the end of the last section, however now we can add as much code as we want to `TracePixel` without cluttering the render hook. Also if you're wondering why we're doing `* 255` on the final RGB vector, instead of using 0-255 colours in `TracePixel`, it's because when doing any kind of rendering having `grey * grey` produce 255 (after clamping) is really not helpful.

To trace our ray, we need to know the start position and the direction to trace in. We'll get into generating camera rays in a bit but for now we're going to do [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection), meaning all of our rays point in the exact same direction and the origin changes. This has the effect of no matter how close or far away something is, it will always look the same in our final image.

We're also going to use the player camera's origin and angles for our rays, although you could use anything you want
~~~ lua highlight
local camPos, camAng = LocalPlayer():EyePos(), LocalPlayer():EyeAngles()
~~~ lua
local function TracePixel(x, y)
	~~~ lua highlight
	local origin = camPos + camAng:Right() * x / RESX * 100 + camAng:Up() * (1 - y / RESY) * 100
	local camDir = camAng:Forward()

	local result = accel:Traverse(origin, camDir)
	if result then
		return Vector(1, 1, 1)
	else
		return Vector(0, 0, 0)
	end
	~~~ lua delete
	return Vector(x / (RESX - 1), y / (RESY - 1), 0)
	~~~ lua
end
~~~

![Kleiner sitting on a crate](./images/vistracing-in-one-weekend/orthographic.png)

Because we're just adding onto the player camera's position the rays aren't centred, so you'll need to look down and to the left, but we're now tracing a scene!

Ray Tracing
===========

We have pixels being drawn to the screen, and we have rays being traced, now it's time to simulate light with ray tracing. I wont bore you with a bunch of theory right away, but I will give you an overview of how the ray tracing algorithm works.

We start by generating a ray from a pixel given our camera's properties as well as any additional properties that affect ray generation (like jittering for MSAA), we then trace this ray out into the scene to get a hit point. If we missed it's up to us how we want to colour that pixel, however if we hit an object we plug the information about the hit as well as our ray into the *rendering equation*, which will determine the colour of the hit point that we then assign to the pixel.

Generating Camera Rays
----------------------

The Rendering Equation
----------------------

\begin{equation}
L_o(\mathbf{x}, \omega_o, \lambda, t) = L_e(\mathbf{x}, \omega_o, \lambda, t) + \int_{\Omega} f_r(\mathbf{x}, \omega_i, \omega_o, \lambda, t)L_i(\mathbf{x}, \omega_i, \lambda, t)(\omega_i \cdot \mathbf{n}) \,d\omega_i
\end{equation}

Lighting
--------

Reflection and Refraction
-------------------------

Post Processing
---------------

Conclusion
----------

Path Tracing
============

Revisiting the Rendering Equation
----------------------

\begin{equation}
L_o(\mathbf{x}, \omega_o, \lambda, t) = L_e(\mathbf{x}, \omega_o, \lambda, t) + \int_{\Omega} f_r(\mathbf{x}, \omega_i, \omega_o, \lambda, t)L_i(\mathbf{x}, \omega_i, \lambda, t)(\omega_i \cdot \mathbf{n}) \,d\omega_i
\end{equation}

Brute Force Path Tracing
------------------------

Importance Sampling
-------------------

Next Event Estimation
---------------------

Multiple Importance Sampling
----------------------------

Conclusion
----------

Shading
=======

What is a BSDF?
---------------

Using the VisTrace BSDF
-----------------------

Writing Your Own
----------------

The Microfacet Model
--------------------

Choosing F, D, and G
-------------------

Putting it All Together
-----------------------

Further Reading
===============

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><link rel="stylesheet" href="./css/book.css?v=1"><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
